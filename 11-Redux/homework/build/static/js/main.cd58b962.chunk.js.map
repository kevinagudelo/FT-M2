{"version":3,"sources":["actions/index.js","components/Counter.js","reducers/index.js","index.js"],"names":["INCREMENT","DECREMENT","increment","type","decrement","Counter","incrementIfOdd","incrementAsync","this","props","count","onClick","Component","connect","state","initialState","store","createStore","action","cout","ReactDOM","render","document","getElementById"],"mappings":"0LAAaA,EAAY,YACZC,EAAY,YAOZC,EAAY,WACtB,MAAO,CAACC,KAAKH,IAGHI,EAAY,WACvB,MAAO,CAACD,KAAKF,I,OCTTI,E,4MAEFC,eAAiB,a,EAIjBC,eAAiB,a,4CAIjB,WAGI,OACI,4CACgBC,KAAKC,MAAMC,MAD3B,SAEI,wBAAQC,QAAS,aAAjB,gBAGA,wBAAQA,QAAS,aAAjB,wB,GAnBMC,aAiDPC,eAVS,SAACC,GACrB,MAAO,CACHJ,MAAOI,EAAMJ,SAQmB,CAAER,YAAWE,aAAtCS,CAAmDR,G,OCnD5DU,EAAe,CACnBL,MAAO,GCSHM,EAAQC,aDHC,WAAmC,IAAlCH,EAAiC,uDAAzBC,EAAcG,EAAW,uCAC/C,OAAQA,EAAOf,MACb,KAAKH,EAEL,OAAO,2BAAIc,GAAX,IAAkBK,KAAML,EAAMJ,MAAM,IACpC,KAAKT,EAEL,OAAO,2BAAIa,GAAX,IAAkBK,KAAML,EAAMJ,MAAM,IACpC,QACE,OAAOI,MCAbM,IAASC,OACP,cAAC,IAAD,CAAUL,MAAOA,EAAjB,SACE,cAAC,EAAD,MAEFM,SAASC,eAAe,W","file":"static/js/main.cd58b962.chunk.js","sourcesContent":["export const INCREMENT = 'INCREMENT';\nexport const DECREMENT = 'DECREMENT';\n\n// Nuestras actions (action creators) devolverán un paquete de actions que nuestro reducer recibirá. \n// ¿Cómo es el paquete de acción? Tengan en cuenta que el creador de la acción no es en absoluto responsable \n// de manejar ninguna de las lógicas actuales de actualización del store central de Redux.\n// Eso se lo deja al reducer(s).\n\nexport const increment = () => {\n   return({type:INCREMENT})\n};\n\nexport const decrement = () => {\n  return({type:DECREMENT})\n};","import React, { Component } from \"react\";\nimport { connect } from 'react-redux';\nimport { increment, decrement } from '../actions';\n\nclass Counter extends Component {\n    // Extra Credit\n    incrementIfOdd = () => {\n      //Implementar una función de incremento que sólo aumenta si el valor del contador es impar\n    };\n    // Extra Credit\n    incrementAsync = () => {\n        //  Implementar una función de incremento que aumenta después de esperar un segundo\n    };\n\n    render() {\n        // Completa las funciones onClick de los botones\n        // Al hacer clic en estos botones, el recuento debe disminuir o aumentar en consecuencia\n        return (\n            <p>\n                Clickeado: {this.props.count} veces\n                <button onClick={() => {increment}}>\n                    + {/* Incremeta */}\n                </button>\n                <button onClick={() => {decrement }}>\n                    -  {/* Decrementa */}\n                </button>\n                 {/* Si quieres hacer los extra credit puede descomentar las lineas de abajo */}\n                {/* <button onClick={this.incrementIfOdd}>\n                    incrementa si es impar\n                </button>\n                <button onClick={this.incrementAsync}>\n                    Incrementa despues de un segundos\n                </button>  */}\n            </p>\n        );\n    }\n}\n\n// La función mapStateToProps especifica qué porción del árbol de estados necesita recibir este componente.\n// En este caso, dado que nuestro store de redux sólo almacena el valor del contador,\n// este componente recibe el estado completo.\n// Sin embargo, en una aplicación redux más compleja,\n// recibiría sólo las partes relevantes que necesita del objeto de estado.\nconst mapStateToProps = (state) => {\n    return {\n        count: state.count\n    };\n};\n\n// Se llama a la función de connect para que este componente conozca el resto de la arquitectura de redux.\n// Sin esto, este componente es sólo un componente tonto de React.\n//Pasamos todas las funciones que dependen de Redux, junto con el propio componente,\n// para que Redux se dé a conocer a este componente.\nexport default connect(mapStateToProps, { increment, decrement })(Counter);\n","import { INCREMENT, DECREMENT } from '../actions';\n\nconst initialState = {\n  count: 0\n}\n\n// Nuestro reducer que maneja nuestros dos casos de acción incremento y decremento.\n// Recibe el estado de nuestro store, junto con una action creada por nuestro action creator. \n// ¿Qué tiene que hacer el reducer con el contador de cada caso?\nexport default (state = initialState, action) => {\n  switch (action.type) {\n    case INCREMENT:\n    // completa para este caso\n    return {...state, cout: state.count+1}\n    case DECREMENT:\n    // Fill para este otro\n    return {...state, cout: state.count-1}\n    default:\n      return state;\n  }\n};","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { createStore } from 'redux';\nimport { Provider } from 'react-redux';\nimport Counter from './components/Counter';\nimport counter from './reducers';\n\n// Esta línea instancia nuestro store central de Redux.\n// La función `createStore` recibe el reducer\n// que es responsable de la actualización del store , junto\n//con cualquier estado inicial con el que queramos que\n//empiece el store (que en este caso es ninguno).\nconst store = createStore(counter);\n\n// Aquí, envolvemos nuestro componente principal React dentro de las etiquetas del Provider,\n// que vienen del paquete react-redux.\n// Esto es necesario porque el store necesita saber hacia dónde está pasando su estado. \n// El componente Provider es donde \"vive\" el store.\nReactDOM.render(\n  <Provider store={store}>\n    <Counter />\n  </Provider>,\n  document.getElementById('root')\n);"],"sourceRoot":""}